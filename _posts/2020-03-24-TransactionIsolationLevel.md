---
layout:     post                    # 使用的布局(不需要改)
title:      数据库事务隔离级别       # 标题
subtitle:   我是一只被禁足的安小鸟  #副标题
date:       2020-03-24  00:00:02 GMT+0800           # 时间
author:     Zen                      # 作者
header-img: img/photo/birdAngle.webp   #这篇文章标题背景图片
catalog: False                       # 是否归档
tags:                               #标签
    - database
---

+ 读未提交(Read Uncommitted)也称为未授权读取

    允许脏读取,但不允许更新丢失.如果一个事务已经开始写数据,则另外一个事务则不允许同时进行写操作,但允许其他事务读此行数据.该隔离级别可以通过"排他写锁"实现.
+ 读提交(Read Committed)也称为授权读取

    允许不可重复读取,但不允许脏读取.读取数据的事务允许其他事务继续访问该行数据,但是未提交的写事务将会禁止其他事务访问该行.可以通过"瞬间共享读锁"和"排他写锁"实现.
+ 可重复读(Repeated Read)

    禁止不可重复读取和脏读取,但是有时可能出现幻读数据.读取数据的事务将会禁止写事务(但允许读事务),写事务则禁止任何其他事务.可以通过"共享读锁"和"排他写锁"实现.
+ 串行化/序列化(Serializable)

    提供严格的事务隔离.它要求事务序列化执行,事务只能一个接着一个地执行,不能并发执行.仅仅通过"行级锁"是无法实现事务序列化的,必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到.

    隔离级别越高,越能保证数据的完整性和一致性,但是对并发性能的影响也越大.对于多数应用程序,可以优先考虑把数据库系统的隔离级别设为Read Committed.它能够避免脏读取,而且具有较好的并发性能.尽管它会导致不可重复读\幻读和第二类丢失更新这些并发问题,在可能出现这类问题的个别场合,可以由应用程序采用悲观锁或乐观锁来控制.

---
悲观锁就是for update(锁定查询的行)
乐观锁就是 version字段(比较跟上一次的版本号,如果一样则更新,如果失败则要重复读-比较-写的操作.)适用于多读少写的应用场景
