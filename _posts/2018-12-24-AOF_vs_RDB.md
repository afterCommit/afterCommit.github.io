---
layout:     post                    # 使用的布局（不需要改）
title:      AOF vs RDB               # 标题
subtitle:   新生儿的第一句话,Hello World #副标题
date:       2018-12-24              # 时间
author:     Zen                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: False                       # 是否归档
tags:                               #标签
    - Redis
---

|RDB|AOF
---|:--:|---:
Advantage| 1. RDB是Redis数据的一个非常紧凑的单文件时间点表示。RDB文件非常适合备份。例如,您可能希望在最近的24小时内每小时归档RDB文件,并在30天内每天保存RDB快照。这允许您在发生灾难时轻松恢复数据集的不同版本。保存整体快照增量备份2. RDB对于灾难恢复非常有用,因为单个压缩文件可以传输到远程数据中心,或者Amazon S3(可能是加密的)上。单文件传送到数据中心或云端3. RDB最大限度地提高了Redis的性能,因为Redis父进程需要做的唯一工作就是创建一个子进程来执行其余的所有工作。父实例永远不会执行磁盘I/O或类似的操作。不占用父进程4. 与AOF相比,RDB允许使用大数据集更快地重新启动。不需要play again|1. Redis可以自动重写背景中的AOF,当它变得太大。重写是完全安全,复述,继续追加到旧文件,产生一个全新的最小集合操作需要创建当前数据集,而一旦准备复述,开关的两个和第二个文件附加到新的一个开始。并且支持后台备份2. AOF以一种易于理解和解析的格式,一个接一个地记录所有操作的日志。您甚至可以轻松导出AOF文件。例如,即使您使用FLUSHALL命令刷新了所有错误,如果在此期间没有执行日志重写,您仍然可以保存数据集,只需停止服务器,删除最新的命令,并再次启动Redis。
Disadvantage|1. 如果需要在Redis停止工作(例如停电之后)时最小化数据丢失的机会,那么RDB就不是很好。可以在生成RDB的地方配置不同的保存点(例如,对数据集进行至少5分钟和100次写操作之后,但是可以有多个保存点)。但是,通常每5分钟或更长时间创建一个RDB快照,因此,如果Redis停止工作而没有正确地关闭,您应该准备好丢失最新的几分钟数据。按照预先设定的时间间隔备份,两次备份中间的数据有可能在断电时丢失2. RDB通常需要fork(),以便使用子进程将其持久化到磁盘上。如果数据集很大,Fork()可能会很耗时,如果数据集很大,CPU性能不是很好,可能会导致Redis在几毫秒甚至一秒内停止为客户机提供服务。AOF还需要fork(),但是您可以调优重写日志的频率,而不必牺牲持久性。创建子进程可能会暂时停止响应|1. 对于相同的数据集,AOF文件通常比等效的RDB文件大2.根据确切的fsync策略,AOF可能比RDB慢。一般来说,fsync设置为每秒的性能仍然很高,如果禁用fsync,即使在高负载下,它的速度也应该和RDB一样快。尽管如此,RDB仍然能够提供关于最大延迟的更多保证,即使在写入负载很大的情况下也是如此.在过去,我们在特定的命令中遇到过罕见的错误(例如,有一个错误涉及像BRPOPLPUSH这样的阻塞命令),导致在重新加载时生成的AOF不能完全复制相同的数据集。这种bug很少见,我们在测试套件中进行了测试,自动创建随机的复杂数据集并重新加载它们,以检查一切是否正常,但是使用RDB持久性,这种bug几乎是不可能的。为了更清楚地说明这一点:Redis AOF会像MySQL或MongoDB那样增量地更新现有状态,而RDB快照会一次又一次地从头创建一切,这在概念上更健壮。然而需要注意的是,每次AOF是重写的复述,从头重新创建从实际数据中包含的数据集,使错误更强而总是附加阻力AOF文件(或一个重写阅读旧AOF代替阅读数据在内存中我们从来没有收到过来自用户的关于在现实世界中检测到的AOF失败的报告。
step|• Redis forks. We now have a child and a parent process.创建子进程• The child starts to write the dataset to a temporary RDB file.子进程写数据到临时RDB文件When the child is done writing the new RDB file, it replaces the old one.当子进程完成写操作后替换旧RDB|• Redis forks, so now we have a child and a parent process.创建子进程• The child starts writing the new AOF in a temporary file.子进程写新AOF到临时文件• The parent accumulates all the new changes in an in-memory buffer (but at the same time it writes the new changes in the old append-only file, so if the rewriting fails, we are safe).父类将所有新更改累积到内存缓冲区中(但同时它将新更改写入仅用于追加的旧文件中,因此如果重写失败,我们是安全的)。• When the child is done rewriting the file, the parent gets a signal, and appends the in-memory buffer at the end of the file generated by the child.当子节点重写文件完成时,父节点得到一个信号,并在子节点生成的文件的末尾追加内存缓冲区。• Profit! Now Redis atomically renames the old file into the new one, and starts appending new data into the new file.
